package com.yey.thread;

public class a06线程生命周期 {
    /**
     * 新建: 当一个Thread类或其子类的对象被声明并创建,新生的线程对象处于新建状态.
     * 就绪: 处于新建状态的线程被start()后,将进入线程队列等待CPU时间片,此时已具备了运行条件,只是没分配到CPU资源.
     * 运行: 当就绪的线程被调度并获得CPU资源时,便进入运行状态,run()方法定义了线程的操作和功能.
     * 阻塞: 在某种特殊情况下,被人为挂起或执行输入输出操作时,让出CPU并临时暂停自己的执行,进入阻塞状态.
     * 死亡: 线程完成了它的全部工作或线程被提前强制性的中止或出现异常导致结束.
     */
    /**
     * 运行状态切换到阻塞状态可以使用那些方法:
     * 1. sleep(): 当sleep()时间到,线程就从阻塞->就绪
     * 2. join(): 当前线程中,其他线程调用了join(),等到其他线程执行完成后,当前线程会从阻塞状态到就绪状态转变.
     * 3. 等待同步锁时是阻塞状态->获取到同步锁时就变为就绪状态
     * 4. wait():线程阻塞状态后被notify()或者notifyAll(),线程由阻塞->就绪状态.
     * 5. suspend(): 当前线程挂起,当调用resume(),线程由阻塞变为就绪.这两个API废弃了,容器导致死锁.
     */

    /**
     * 线程安全问题如何出现的?
     * 当前线程执行过程中对共享数据操作还未执行完成,其他线程也开始对共享数据进行操作,这样就会导致线程安全的问题.
     */
}
